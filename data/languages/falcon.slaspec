# Specification for the Nvidia Falcon

define endian=little;
define alignment=1;

define space ram type=ram_space size=4 default;
define space register type=register_space size=4;

# gpr
define register offset=0 size=4 [r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15];

# TODO: define flags?
define register offset=0x40 size=4 [iv0 iv1 _ tv sp pc xcbase xdbase flags cx cauth xtargets tstatus];

# 8 bits format & size of opcode
define token opcode_len_format (8)
  # raw opcode for unsized instructions
  raw_opcode=(0, 7)
  raw_opcode_lo=(0, 3)
  raw_opcode_hi=(4, 7)
  op_size=(6, 7)
  op_format=(0, 5)
  o1_format=(0, 3)
  reg0=(0, 3)
;

define token opcode_extra8 (8)
  reg2=(0, 3)
  reg1=(4, 7)
  subopcode2=(0, 3)
  pred1=(0, 2)
;

define token immediate8 (8)
  imm8=(0, 7)
  imm8s=(0, 7) signed
  fimm8=(0, 7)
  fimm8s=(0, 7) signed
;

define token opcode_extra16 (16)
  imm16=(0, 15)
  imm16s=(0, 15) signed
  fimm16s=(0, 15) signed
;

define token opcode_extra24 (24)
  fimm24s=(0, 23) signed
;

define token opcode_extra32 (32)
  fimm32=(0, 31)
;


# FIXME: this is wrong, redefine every opcode* tokens
define token opcode16 (24)
  imm8h=(16, 23)
  pred2=(16, 18)
  creg1=(16, 18)
  creg2=(20, 22)
  reg3=(20, 23)
  fimm16=(8, 23)
  strap=(8, 9)
;

define token opcode24 (32)
  imm16w=(16, 31)
  imm16h=(16, 31)

  fimm24=(8, 31)
  cimm2=(20, 25)
;

# TODO: define opcode48 (seems used for bra on fuc5)

attach variables [ reg0 reg1 reg2 reg3 ]
[
  r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15
];

@include "fuc5_inst.sinc"

define pcodeop exit;

# constructor start

# unsized op start

# 0xCX start
:mulu reg2, reg1, imm8 is raw_opcode=0xc0; reg2 & reg1; imm8 {
  # TODO
}

:muls reg2, reg1, imm8s is raw_opcode=0xc1; reg2 & reg1; imm8s {
  # TODO
}

:sext reg2, reg1, imm8 is raw_opcode=0xc2; reg2 & reg1; imm8 {
  # TODO
}

:and reg2, reg1, imm8 is raw_opcode=0xc4; reg2 & reg1; imm8 {
  # TODO
}

:or reg2, reg1, imm8 is raw_opcode=0xc5; reg2 & reg1; imm8 {
  # TODO
}

:xor reg2, reg1, imm8 is raw_opcode=0xc6; reg2 & reg1; imm8 {
  # TODO
}

:xbit reg2, reg1, imm8 is raw_opcode=0xc8; reg2 & reg1; imm8 {
  # TODO
}

# TODO: CE?

:iord reg2, [reg1^"+"^offset] is raw_opcode=0xcf; reg2 & reg1; imm8 [ offset=imm8 * 4; ] {
  # TODO
}

# 0xCX end

# 0xEX start
:mulu reg2, reg1, imm16 is raw_opcode=0xe0; reg2 & reg1; imm16 {
  # TODO
}

:muls reg2, reg1, imm16s is raw_opcode=0xe1; reg2 & reg1; imm16s {
  # TODO
}

:and reg2, reg1, imm16 is raw_opcode=0xe4; reg2 & reg1; imm16 {
  # TODO
}

:or reg2, reg1, imm16 is raw_opcode=0xe5; reg2 & reg1; imm16 {
  # TODO
}

:xor reg2, reg1, imm16 is raw_opcode=0xe6; reg2 & reg1; imm16 {
  # TODO
}
# 0xEX end


# 0xF0 & 0xF1 start
# FIXME: ellipsis are broken because of limitation at the token level,
# A way of fixing it would be to define a 16 bits long token containing opcode_len_format & opcode_extra8

:mulu reg1, imm8 is raw_opcode=0xf0; subopcode2=0x0 & reg1; imm8  {
  # TODO
}

:muls reg1, imm8s is raw_opcode=0xf0; subopcode2=0x1 & reg1; imm8s {
  # TODO
}

:sext reg1, imm8 is raw_opcode=0xf0; subopcode2=0x2 & reg1; imm8 {
  # TODO
}

# TODO: sethi

:and reg1, imm8 is raw_opcode=0xf0; subopcode2=0x4 & reg1; imm8 {
  # TODO
}

:or reg1, imm8 is raw_opcode=0xf0; subopcode2=0x5 & reg1; imm8 {
  # TODO
}

:xor reg1, imm8 is raw_opcode=0xf0; subopcode2=0x6 & reg1; imm8 {
  # TODO
}

:bset reg1, imm8 is raw_opcode=0xf0; subopcode2=0x9 & reg1; imm8 {
  # TODO
}

:bclr reg1, imm8 is raw_opcode=0xf0; subopcode2=0xa & reg1; imm8 {
  # TODO
}

:btgl reg1, imm8 is raw_opcode=0xf0; subopcode2=0xb & reg1; imm8 {
  # TODO
}
# 0xF0 & 0xF1 end

:exit is raw_opcode=0xf8; subopcode2=0x02 {
  exit();
}
# unsized op end
