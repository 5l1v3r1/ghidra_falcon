# Specification for the Nvidia Falcon

define endian=little;
define alignment=1;

define space ram type=ram_space size=4 default;
define space register type=register_space size=4;

# gpr
define register offset=0 size=4 [r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15];

# TODO: define flags?
define register offset=0x40 size=4 [iv0 iv1 _ tv sp pc xcbase xdbase flags cx cauth xtargets tstatus];

# 8 bits format & size of opcode
define token opcode_len_format (8)
  # raw opcode for unsized instructions
  raw_opcode=(0, 7)
  raw_opcode_lo=(0, 3)
  raw_opcode_hi=(4, 7)
  op_size=(6, 7)
  op_format=(0, 5)
  o1_format=(0, 3)
  reg0=(0, 3)
;

define token opcode_extra8 (8)
  reg2=(0, 3)
  reg1=(4, 7)
  subopcode2=(0, 3)
  pred1=(0, 2)
;

define token immediate8 (8)
  imm8=(0, 7)
  imm8s=(0, 7) signed
  fimm8=(0, 7)
  fimm8s=(0, 7) signed
;

define token opcode_extra16 (16)
  fimm16s=(0, 15) signed
;

define token opcode_extra24 (24)
  fimm24s=(0, 23) signed
;


# FIXME: this is wrong, redefine every opcode* tokens
define token opcode16 (24)
  imm8h=(16, 23)
  pred2=(16, 18)
  creg1=(16, 18)
  creg2=(20, 22)
  reg3=(20, 23)
  fimm16=(8, 23)
  strap=(8, 9)
;

define token opcode24 (32)
  imm16=(16, 31)
  imm16w=(16, 31)
  imm16h=(16, 31)
  imm16s=(16, 31) signed
  fimm24=(8, 31)
  cimm2=(20, 25)
;

define token opcode32 (48)
  fimm32=(8, 39)
;

# TODO: define opcode48 (seems used for bra on fuc5)

attach variables [ reg0 reg1 reg2 reg3 ]
[
  r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15
];

define pcodeop exit;

# constructor start


# unsized op start

# 0xCX start
:mulu reg2, reg1, imm8 is raw_opcode=0xc0; reg2 & reg1; imm8 {
  # TODO
}

:muls reg2, reg1, imm8s is raw_opcode=0xc1; reg2 & reg1; imm8s {
  # TODO
}

:sext reg2, reg1, imm8 is raw_opcode=0xc2; reg2 & reg1; imm8 {
  # TODO
}

:and reg2, reg1, imm8 is raw_opcode=0xc4; reg2 & reg1; imm8 {
  # TODO
}

:or reg2, reg1, imm8 is raw_opcode=0xc5; reg2 & reg1; imm8 {
  # TODO
}

:xor reg2, reg1, imm8 is raw_opcode=0xc6; reg2 & reg1; imm8 {
  # TODO
}

:xbit reg2, reg1, imm8 is raw_opcode=0xc8; reg2 & reg1; imm8 {
  # TODO
}

# TODO: CE?

:iord reg2, [reg1^"+"^offset] is raw_opcode=0xcf; reg2 & reg1; imm8 [ offset=imm8 * 4; ] {
  # TODO
}

# 0xCX end

:exit is raw_opcode=0xf8; subopcode2=0x02 {
  exit();
}
# unsized op end

# 3 bytes op start
:mov reg0, fimm8s is raw_opcode_hi=0x00 & reg0; fimm8s {
  reg0 = fimm8s;
}
# 3 bytes op end

# 4 bytes op start
:mov reg0, fimm16s is raw_opcode_hi=0x4 & reg0; fimm16s {
  reg0 = fimm16s;
}
# 4 bytes op end


# 5 bytes op start
:mov reg0, fimm24s is raw_opcode_hi=0x8 & reg0; fimm24s {
  reg0 = fimm24s;
}
# 5 bytes op end